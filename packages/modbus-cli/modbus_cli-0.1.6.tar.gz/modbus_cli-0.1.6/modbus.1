.\" Man page generated from reStructuredText.
.
.TH MODBUS 1 "2017-06-04" "0.1.4" ""
.SH NAME
modbus \- Access Modbus devices from the command line
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
modbus [\-h] [\-r REGISTERS] [\-s SLAVE_ID] [\-b BAUD] [\-p STOP_BITS] [\-v] device access [access ...]
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
Read and write registers of Modbus devices.
.sp
Access both TCP and RTU (i.e. serial) devices and encode and decode types
larger than 16 bits (e.g. floats) into Modbus 16 bits registers.
.sp
Optionally access registers by symbolic names, as defined in a registers file.
.sp
Implemented in python on top of the protocol implementation provided by the
umodbus python library.
.SH OPTIONS
.INDENT 0.0
.TP
.B device
\fB/dev/ttyXXX\fP for serial devices, or \fBhostname[:port]\fP for TCP devices
.TP
.B access
One or more read or write operations. See ACCESS SYNTAX below.
.UNINDENT
.INDENT 0.0
.TP
.BI \-r \ FILE\fP,\fB \ \-\-registers\fB= FILE
Read registers definitions from FILE. Can be specified multiple times.
.TP
.B \-v\fP,\fB  \-\-verbose
Print on screen the bytes transferred on the wire.
.TP
.BI \-b \ BAUD\fP,\fB \ \-\-baud\fB= BAUD
Set the baud rate for serial connections.
.TP
.BI \-p \ BITS\fP,\fB \ \-\-stop\-bits\fB= BITS
Set the number of stop bits for serial connections.
.TP
.B \-h\fP,\fB  \-\-help
Show this help message and exit.
.UNINDENT
.SH ACCESS SYNTAX
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[MODBUS_TYPE@]ADDRESS[/BINARY_TYPE][:ENUMERATION_NAME][=VALUE]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Mnemonic: access the register(s) of MODBUS_TYPE starting \fIat\fP ADDRESS,
interpreting them as BINARY_TYPE. The \fB/\fP syntax is inspired by gdb (but the
available types are different.)
.INDENT 0.0
.TP
.B MODBUS_TYPE = h|i|c|d
The modbus type, one of
.TS
center;
|l|l|l|l|.
_
T{
code
T}	T{
name
T}	T{
size
T}	T{
writable
T}
_
T{
\fBh\fP
T}	T{
holding register
T}	T{
16 bits
T}	T{
yes
T}
_
T{
\fBi\fP
T}	T{
input register
T}	T{
16 bits
T}	T{
no
T}
_
T{
\fBc\fP
T}	T{
coil
T}	T{
1 bit
T}	T{
yes
T}
_
T{
\fBd\fP
T}	T{
discrete input
T}	T{
1 bit
T}	T{
no
T}
_
.TE
.UNINDENT
.sp
The default modbus type is holding register.
.INDENT 0.0
.TP
.B ADDRESS = <number>
0\-based register address
.TP
.B BINARY_TYPE = <pack format>
Any format description accepted by the python standard \fBpack\fP module. Some common formats are:
.TS
center;
|l|l|.
_
T{
code
T}	T{
type
T}
_
T{
\fBh\fP
T}	T{
16 bits signed integer
T}
_
T{
\fBH\fP
T}	T{
16 bits unsigned integer
T}
_
T{
\fBi\fP
T}	T{
32 bits signed integer
T}
_
T{
\fBI\fP
T}	T{
32 bits unsigned integer
T}
_
T{
\fBf\fP
T}	T{
32 bits IEEE 754 float
T}
_
.TE
.sp
The default byte order is big\-endian, use a \fB<\fP prefix in the format to specify little\-endian.
.TP
.B VALUE = <number>
The value to be written to the register. If not present, the register will be read instead.
.UNINDENT
.SH EXAMPLES
.SS Read a holding register
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ modbus $IP_OF_MODBUS_DEVICE 100
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Write a holding register
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ modbus $IP_OF_MODBUS_DEVICE 100=42
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Read multiple registers
.sp
To read (or write) multiple registers simply list them on the command line:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ modbus $IP_OF_MODBUS_DEVICE 100 c@2000
.ft P
.fi
.UNINDENT
.UNINDENT
.SS More examples of the access syntax
.TS
center;
|l|l|.
_
T{
\fBh@39/I\fP
T}	T{
read the 32\-bits unsigned integer stored in holding registers at addresses 39 and 40
T}
_
T{
\fB39/I\fP
T}	T{
same as above (h is the default modbus type)
T}
_
T{
\fB39/I=42\fP
T}	T{
write the integer 42 to that register
T}
_
T{
\fBSOME_REGISTER=42\fP
T}	T{
same as above, provided the registers file contains the definition \fBSOME_REGISTER h@39/I\fP
T}
_
T{
\fB39/I=0xcafe\fP
T}	T{
the value can be specified in hexadecimal
T}
_
T{
\fBc@5\fP
T}	T{
read coil at address 5
T}
_
T{
\fBh@24/f=6.78\fP
T}	T{
write a floating point value to holding registers at addresses 24 and 25
T}
_
T{
\fBi@1/6B\fP
T}	T{
read six unsigned bytes stored in input registers at addresses 1, 2 and 3
T}
_
.TE
.SS Monitor a register
.sp
The UNIX command \fBwatch\fP can be used to read a register at regular intervals:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ watch modbus $IP_OF_MODBUS_DEVICE 100
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Read a serial device attached to a remote computer
.sp
The UNIX command \fBsocat\fP can be used to access a remote device through a TCP
tunnel:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
remote$ socat \-d \-d tcp\-l:54321,reuseaddr file:/dev/ttyUSB0,raw,b19200
local$ socat \-d \-d tcp:sc:54321 pty,waitslave,link=/tmp/local_device,unlink\-close=0
local$ modbus /tmp/local_device 100
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Read multiple registers based on their names
.sp
Given the following registers definitions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ cat registers.modbus
di0 d@0
di1 d@1
ai0 i@512
ai1 i@513
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
glob matching (*, ?, etc.) can be used to read all the \fBai\fP registers at once:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ modbus \-r registers.modbus $IP_OF_MODBUS_DEVICE ai\e*
.ft P
.fi
.UNINDENT
.UNINDENT
.SH REGISTERS FILES
.sp
The purpose of the registers files is to be able to refer to registers by name.
.sp
There can be multiple definition files, specified using either the \fB\-r\fP
command line switch or the \fBMODBUS_DEFINITIONS\fP environment variable.
.sp
A \fB#\fP in a definition file starts a comment.
.sp
Each line contains a symbolic name followed by a register definition. The name
and the definitions are separated by spaces, for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
status i@512:STATUS
leds 513:LEDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The file can also contain the possible values for an enumeration or a bitmask,
for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# This is an enumeration named STATUS
:STATUS
  0=OFF
  1=ON
  2=ERROR

# This is a bitmask named LEDS
|LEDS
  0=LED0
  1=LED1
  3=LED3
  4=LED4
.ft P
.fi
.UNINDENT
.UNINDENT
.SH ENVIRONMENT
.INDENT 0.0
.TP
.B MODBUS_DEFINITIONS
A colon separated list of register definitions files.
.UNINDENT
.SH SEE ALSO
.INDENT 0.0
.IP \(bu 2
\fI\%modbus\fP
.IP \(bu 2
\fI\%umodbus\fP
.IP \(bu 2
\fI\%pack format\fP
.UNINDENT
.SH AUTHOR
favalex@gmail.com
.SH COPYRIGHT
MPL 2.0
.\" Generated by docutils manpage writer.
.
