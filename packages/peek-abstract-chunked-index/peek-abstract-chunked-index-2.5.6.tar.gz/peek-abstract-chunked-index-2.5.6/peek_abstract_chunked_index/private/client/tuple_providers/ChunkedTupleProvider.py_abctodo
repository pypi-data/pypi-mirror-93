import json
from collections import defaultdict
from typing import Union, List

from twisted.internet.defer import Deferred
from vortex.DeferUtil import deferToThreadWrapWithLogger
from vortex.Payload import Payload
from vortex.TupleSelector import TupleSelector
from vortex.handler.TupleDataObservableHandler import TuplesProviderABC

from peek_abstract_chunked_index._private.client.controller.ChunkedIndexCacheController import \
    ChunkedIndexCacheController
from peek_abstract_chunked_index._private.storage.ChunkedIndexEncodedChunk import \
    ChunkedIndexEncodedChunk
from peek_abstract_chunked_index._private.worker.tasks._ChunkedIndexCalcChunkKey import \
    makeChunkKey
from peek_abstract_chunked_index.tuples.ChunkedTuple import ChunkedTuple



class ChunkedTupleProvider(TuplesProviderABC):
    def __init__(self, cacheHandler: ChunkedIndexCacheController):
        self._cacheHandler = cacheHandler

    @deferToThreadWrapWithLogger(logger)
    def makeVortexMsg(self, filt: dict,
                      tupleSelector: TupleSelector) -> Union[Deferred, bytes]:
        modelSetKey = tupleSelector.selector["modelSetKey"]
        keys = tupleSelector.selector["keys"]

        keysByChunkKey = defaultdict(list)

        results: List[ChunkedTuple] = []

        for key in keys:
            keysByChunkKey[makeChunkKey(modelSetKey, key)].append(key)

        for chunkKey, subKeys in keysByChunkKey.chunkeds():
            chunk: ChunkedIndexEncodedChunk = self._cacheHandler.encodedChunk(chunkKey)

            if not chunk:
                logger.warning("ChunkedIndex chunk %s is missing from cache", chunkKey)
                continue

            resultsByKeyStr = Payload().fromEncodedPayload(chunk.encodedData).tuples[0]
            resultsByKey = json.loads(resultsByKeyStr)

            for subKey in subKeys:
                if subKey not in resultsByKey:
                    logger.warning(
                        "Chunked %s is missing from index, chunkKey %s",
                        subKey, chunkKey
                    )
                    continue

                packedJson = resultsByKey[subKey]

                results.append(ChunkedTuple.unpackJson(subKey, packedJson))

        # Create the vortex message
        return Payload(filt, tuples=results).makePayloadEnvelope().toVortexMsg()
