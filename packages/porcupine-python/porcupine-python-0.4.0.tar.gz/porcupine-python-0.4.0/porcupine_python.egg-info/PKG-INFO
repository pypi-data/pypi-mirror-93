Metadata-Version: 2.1
Name: porcupine-python
Version: 0.4.0
Summary: A library designed primarily for serializing objects using type checking and resolvers.
Home-page: https://github.com/zurek11/simple_serializer
Author: Adam ≈Ω√∫rek
Author-email: adamzurek14@gmail.com
License: MIT
Description: # porcupine-python
        
        [![codecov](https://codecov.io/gh/zurek11/porcupine-python/branch/master/graph/badge.svg)](https://codecov.io/gh/zurek11/porcupine-python)
        
        Hi. I am a fucking porcupine ü¶î. I am here to serialize your responses üí™. 
        
        ## Usage
        
        porcupine-python is used for type and nested serialization of any objects with attributes into dictionaries.
        
        ### Simple usage
        
        First we need to create some simple class:
        
        ```python
        class User(object):
            def __init__(self, name=None, surname=None, age=None):
                self.name = name
                self.surname = surname
                self.age = age
        ```
        
        Second we create serializer for this type of class:
        
        ```python
        from porcupine.base import Serializer
        
        class UserSerializer(Serializer):
            name: str
            surname: str
            age: int = None
        ```
        
        Final usage with different created instances looks like this:
        
        ```python
        # User instance with all attributes
        user = User('foo', 'bar', 23)
        
        dictionary = UserSerializer(user).dict()
        # dictionary: {'name': 'foo', 'surname': 'bar', 'age': 23}
        
        # User instance with only required attributes
        user = User('foo', 'bar')
        
        dictionary = UserSerializer(user).dict()
        # dictionary: {'name': 'foo', 'surname': 'bar', 'age': None}
        
        # User instance with all None attributes
        user = User()
        
        dictionary = UserSerializer(user).dict()
        # raised ValidationError
        ```
        
        ### Usage of resolvers
        
        First we need to create some class which instances will be resolved:
        
        ```python
        class User(object):
            def __init__(self, name=None, surname=None, age=None):
                self.name = name
                self.surname = surname
        ```
        
        Serializer for that class:
        
        ```python
        from porcupine.base import Serializer
        
        class UserSerializer(Serializer):
            name: str = None
            surname: str = None
            full_name: str = None
        
            @staticmethod
            def resolve_full_name(data):
                fullname = None
        
                if data.name and data.surname:
                    fullname = f'{data.name} {data.surname}'
                elif data.name:
                    fullname = data.name
                elif data.surname:
                    fullname = data.surname
        
                return fullname
        ```
        
        Serialized user instance:
        
        ```python
        user = User('foo', 'bar')
        
        dictionary = UserSerializer(user).dict()
        # dictionary: {'name': 'foo', 'surname': 'bar', 'full_name': 'foo bar'}
        ```
        
        ---
        Made with ‚ù§ by Adam ≈Ω√∫rek & [BACKBONE s.r.o.](https://www.backbone.sk/en/)
        
        ## 0.1.0 : 2020-05-26
        
        - Initial release
        
        ## 0.2.0 : 2020-06-27
        
        - Fixed Expected type 'Dict[str, Any]' warning when calling BaseSerializer
        - Implemented test for nested objects.
        
        ## 0.3.0 : 2020-11-27
        
        - ü¶¶ Implemented possibility to add custom arguments to serializers.
        - ü¶¶ Pydantic version requirement changed from `1.4.*` to `1.7.*`.
        
        ## 0.4.0 : 2021-02-02
        
        - üé∏ Support for nested serializers.
        - üé∏ Support for list of serializers.
        
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Topic :: Software Development :: Libraries
Description-Content-Type: text/markdown
